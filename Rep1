import os
import schedule
import time
import datetime
import socket
import psycopg2
import requests
import logging
import csv
from tabulate import tabulate

# Configure logging
logging.basicConfig(
    filename="replication_stats.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

# Set your PostgreSQL connection parameters
db_params = {
    "host": "your_postgres_host",
    "database": "your_database",
    "user": "your_user",
    "password": "your_password",
}

# Set the Confluence API endpoint and credentials
confluence_api_url = "https://your-confluence-site/rest/api/content/YOUR_PAGE_ID"  # Update with your Confluence page URL
confluence_username = "your_username"
confluence_password = "your_password"

# Directory to store data files
data_directory = "data"

# Function to fetch replication statistics with a timestamp column
def get_replication_stats():
    try:
        connection = psycopg2.connect(**db_params)
        cursor = connection.cursor()

        # Get replication statistics with headers
        cursor.execute("SELECT NOW() AS timestamp, * FROM pg_stat_replication;")
        replication_stats = cursor.fetchall()

        return replication_stats
    except Exception as e:
        logging.error("Error fetching replication stats: %s", str(e))
    finally:
        if connection:
            connection.close()

# Function to fetch replication slots with a timestamp column
def get_replication_slots():
    try:
        connection = psycopg2.connect(**db_params)
        cursor = connection.cursor()

        # Get replication slots with headers
        cursor.execute("SELECT NOW() AS timestamp, * FROM pg_replication_slots;")
        replication_slots = cursor.fetchall()

        return replication_slots
    except Exception as e:
        logging.error("Error fetching replication slots: %s", str(e))
    finally:
        if connection:
            connection.close()

# Function to write data to a CSV file with timestamp and hostname
def write_to_csv(data, query_type):
    current_week = datetime.datetime.now().strftime("%U")
    filename = os.path.join(data_directory, f"{query_type}_week_{current_week}.csv")

    with open(filename, mode='a', newline='') as file:
        writer = csv.writer(file)
        if os.path.getsize(filename) == 0:
            # Write headers only if the file is empty
            writer.writerow(["Timestamp", "Hostname"] + data[0].keys())
        for row in data:
            writer.writerow([row['timestamp'], socket.gethostname()] + list(row.values())[1:])

# Function to publish file content as a Confluence attachment
def publish_to_confluence(filename, query_type):
    auth = (confluence_username, confluence_password)

    # Get the current Confluence page ID from the URL
    confluence_page_id = confluence_api_url.split("/")[-1]

    # Define the URL for uploading an attachment to the Confluence page
    upload_url = f"https://your-confluence-site/rest/api/content/{confluence_page_id}/child/attachment"

    # Set the headers for the attachment
    headers = {
        "X-Atlassian-Token": "nocheck",  # Disable CSRF token
    }

    with open(filename, "rb") as file:
        # Create a new attachment on the Confluence page
        response = requests.post(upload_url, auth=auth, headers=headers, files={"file": file})
        if response.status_code == 200:
            logging.info(f"Uploaded {query_type} attachment to Confluence successfully.")
            os.remove(filename)  # Remove the file after uploading
        else:
            logging.error(f"Error uploading {query_type} attachment to Confluence: {response.text}")

# Schedule the task to run every 2 minutes for replication statistics
schedule.every(2).minutes.do(lambda: write_to_csv(get_replication_stats(), "replication_stats"))

# Schedule the task to run every 2 minutes for replication slots
schedule.every(2).minutes.do(lambda: write_to_csv(get_replication_slots(), "replication_slots"))

# Schedule the publishing task to run every hour for replication statistics
schedule.every().hour.do(lambda: publish_to_confluence(write_to_csv(get_replication_stats(), "replication_stats"), "replication_stats"))

# Schedule the publishing task to run every hour for replication slots
schedule.every().hour.do(lambda: publish_to_confluence(write_to_csv(get_replication_slots(), "replication_slots"), "replication_slots"))

# Create the data directory if it doesn't exist
os.makedirs(data_directory, exist_ok=True)

# Run the scheduled tasks
while True:
    schedule.run_pending()
    time.sleep(1)
